import os
import argparse
import numpy as np
import matplotlib.pyplot as plt
import csv
import logging
from read_rkf.parserkf import KFFile
from mofbattery.read_write import filetyper
# from scm.plams import KFFile

HaToEv = 27.2113845249047

ATOM_COLORS = {
    'H': '#B3E3F5',   # Cyan
    'He': '#D9FFFF',  # Pale cyan
    'Li': '#CC80FF',  # Pale violet
    'Be': '#C2FF00',  # Bright lime
    'B': '#FFB5B5',   # Light pink
    'C': '#909090',   # Dark gray
    'N': '#3050F8',   # Blue
    'O': '#FF0D0D',   # Red
    'F': '#90E050',   # Bright green
    'Ne': '#B3E3F5',  # Cyan
    'Na': '#AB5CF2',  # Purple
    'Mg': '#8AFF00',  # Bright green
    'Al': '#BFA6A6',  # Light gray
    'Si': '#F0C8A0',  # Pale orange
    'P': '#FF8000',   # Orange
    'S': '#FFFF30',   # Yellow
    'Cl': '#1FF01F',  # Bright green
    'Ar': '#80D1E3',  # Pale blue
    'K': '#8F40D4',   # Purple
    'Ca': '#3DFF00',  # Bright green
    'Sc': '#E6E6E6',  # Light gray
    'Ti': '#BFC2C7',  # Gray
    'V': '#A6A6AB',   # Medium gray
    'Cr': '#8A99C7',  # Blue-gray
    'Mn': '#9C7AC7',  # Violet
    'Fe': '#E06633',  # Orange-brown
    'Co': '#F090A0',  # Pink
    'Ni': '#50D050',  # Bright green
    'Cu': '#C88033',  # Copper
    'Zn': '#7D80B0',  # Blue-gray
    'Ga': '#C28F8F',  # Pink-brown
    'Ge': '#668F8F',  # Gray-blue
    'As': '#BD80E3',  # Purple
    'Se': '#FFA100',  # Orange
    'Br': '#A62929',  # Dark red
    'Kr': '#5CB8D1',  # Light blue
    'Rb': '#702EB0',  # Dark purple
    'Sr': '#00FF00',  # Green
    'Y': '#94FFFF',   # Pale blue
    'Zr': '#94E0E0',  # Pale blue
    'Nb': '#73C2C9',  # Blue-green
    'Mo': '#54B5B5',  # Blue-green
    'Tc': '#3B9E9E',  # Dark cyan
    'Ru': '#248F8F',  # Dark cyan
    'Rh': '#0A7D8C',  # Dark cyan
    'Pd': '#006985',  # Blue
    'Ag': '#C0C0C0',  # Silver
    'Cd': '#FFD98F',  # Pale yellow
    'In': '#A67573',  # Light brown
    'Sn': '#668080',  # Gray
    'Sb': '#9E63B5',  # Purple
    'Te': '#D47A00',  # Brown
    'I': '#940094',   # Dark purple
    'Xe': '#429EB0',  # Blue-green
    'Cs': '#57178F',  # Dark purple
    'Ba': '#00C900',  # Green
    'La': '#70D4FF',  # Pale blue
    'Ce': '#FFFFC7',  # Very pale yellow
    'Pr': '#D9FFC7',  # Very pale green
    'Nd': '#C7FFC7',  # Pale green
    'Pm': '#A3FFC7',  # Pale green
    'Sm': '#8FFFC7',  # Pale green
    'Eu': '#61FFC7',  # Pale green
    'Gd': '#45FFC7',  # Pale green
    'Tb': '#30FFC7',  # Pale green
    'Dy': '#1FFFC7',  # Pale green
    'Ho': '#00FF9C',  # Green
    'Er': '#00E675',  # Green
    'Tm': '#00D452',  # Green
    'Yb': '#00BF38',  # Green
    'Lu': '#00AB24',  # Dark green
    'Hf': '#4DC2FF',  # Light blue
    'Ta': '#4DA6FF',  # Light blue
    'W': '#2194D6',   # Blue
    'Re': '#267DAB',  # Blue
    'Os': '#266696',  # Blue
    'Ir': '#175487',  # Dark blue
    'Pt': '#D0D0E0',  # Pale gray
    'Au': '#FFD123',  # Gold
    'Hg': '#B8B8D0',  # Gray
    'Tl': '#A6544D',  # Brown
    'Pb': '#575961',  # Dark gray
    'Bi': '#9E4FB5',  # Purple
    'Po': '#AB5C00',  # Brown
    'At': '#754F45',  # Dark brown
    'Rn': '#428296',  # Blue-green
    'Fr': '#420066',  # Dark purple
    'Ra': '#007D00',  # Dark green
    'Ac': '#70ABFA',  # Pale blue
    'Th': '#00BAFF',  # Light blue
    'Pa': '#00A1FF',  # Blue
    'U': '#008FFF',   # Blue
    'Np': '#0080FF',  # Blue
    'Pu': '#006BFF',  # Blue
    'Am': '#545CF2',  # Blue
    'Cm': '#785CE3',  # Blue-violet
    'Bk': '#8A4FE3',  # Purple
    'Cf': '#A136D4',  # Purple
    'Es': '#B31FD4',  # Purple
    'Fm': '#B31FBA',  # Purple
    'Md': '#B30DA6',  # Purple
    'No': '#BD0D87',  # Purple
    'Lr': '#C70066',  # Dark pink
    'Rf': '#CC0059',  # Dark pink
    'Db': '#D1004F',  # Dark pink
    'Sg': '#D90045',  # Dark pink
    'Bh': '#E00038',  # Dark pink
    'Hs': '#E6002E',  # Dark pink
    'Mt': '#EB0026',  # Dark pink
    'X': 'black'
}

logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')


class PDOSPlotter:
    """
    A class for plotting Projected Density of States (PDOS)
    from AMS BAND RKF files.

    Attributes:
        - path_to_rkf (str): Path to the RKF file generated by AMS BAND.
        - ylim (tuple): Y-axis limits for energy values (in eV).
        - save_path (str): Prefix for output plot and CSV files.
        - shift_to_fermi (bool): Whether to shift the energy scale
            so the Fermi level is at 0.
        - orbital_labels (dict): Maps angular momentum quantum
            numbers to orbital labels.
        - orbital_colors (dict): Maps orbital labels to plot colors.
    """

    def __init__(self, path_to_rkf,
                 ylim=(-10, 10),
                 save_path='PDOS_plot',
                 shift_to_fermi=False):
        self.path_to_rkf = path_to_rkf
        self.ylim = ylim
        self.shift_to_fermi = shift_to_fermi
        self.save_path = save_path
        self.orbital_labels = {0: 's',
                               1: 'p',
                               2: 'd',
                               3: 'f',
                               4: 'g',
                               5: 'h'}
        self.orbital_colors = {
                        's': '#1f77b4',  # blue
                        'p': '#2ca02c',  # green
                        'd': '#ff7f0e',  # orange
                        'f': '#d62728',  # red
                        'g': '#9467bd',  # purple
                        'h': '#8c564b'   # brown
                    }

    def load_data(self):
        """
        Load and preprocess data from the RKF file.

        **Returns:**
            tuple: Processed energy values,
            raw PDOS, atomic and orbital assignments,
            symbols, energy mask, and Fermi energy.
        """
        kf = KFFile(self.path_to_rkf)

        energies_ev = np.array(kf.read('DOS', 'Energies')) * HaToEv
        fermi_ev = kf.read('DOS', 'Fermi Energy') * HaToEv
        if self.shift_to_fermi:
            energies_ev -= fermi_ev

        raw_pdos_flat = np.array(kf.read('DOS', 'DOS per basis function'))
        n_energies = len(energies_ev)
        n_basis_functions = len(raw_pdos_flat) // n_energies
        raw_pdos = raw_pdos_flat.reshape((n_basis_functions, n_energies))

        atoms = np.array(kf.read('DOS', 'Atom per basis function'))
        lvals = np.array(kf.read('DOS', 'L-value per basis function'))
        symbols = kf.read_section('Molecule')['AtomSymbols'].split()

        energy_mask = (energies_ev >= self.ylim[0]) &\
            (energies_ev <= self.ylim[1])

        full_energies_ev = np.array(energies_ev)
        energies_ev = energies_ev[energy_mask]

        return (energies_ev,
                full_energies_ev,
                raw_pdos,
                atoms,
                lvals,
                symbols,
                energy_mask,
                fermi_ev)

    def _write_atom_contribution_csv(self, sorted_top):
        """Save atom-wise contributions to a CSV file."""
        with open(f'{self.save_path}-atom_contribution.csv', 'w', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(["Atom Index", "Symbol", "Number of States"])
            for idx, sym, contrib in sorted_top:
                writer.writerow([idx, sym, f"{contrib:.6f}"])

    def plot_by_atom(self,
                     energies_ev,
                     full_energies_ev,
                     raw_pdos,
                     atoms,
                     symbols,
                     energy_mask,
                     fermi_ev,
                     energy_window
                     ):
        """
        Plot atom-wise PDOS contributions and
        estimate contributions near the Fermi level.

        **Parameter:**
            - energies_ev (np.ndarray): Energy values (masked).
            - full_energies_ev (np.ndarray): Full energy values.
            - raw_pdos (np.ndarray): Raw PDOS array.
            - atoms (np.ndarray): Atom indices per basis function.
            - symbols (list): Atomic symbols.
            - energy_mask (np.ndarray): Energy mask.
            - fermi_ev (float): Fermi energy in eV.
            - energy_window (float): Energy window around
                the Fermi level for contributions.

        **Returns:**
            - matplotlib.axes.Axes: Axes of the plot.
            - list: Sorted list of atom contributions
                to the Fermi level.
        """
        fig, ax = plt.subplots(figsize=(6, 10))
        bottom = np.zeros_like(energies_ev)
        top_atoms = []

        unique_symbols = list(dict.fromkeys(symbols))
        # colors = plt.cm.tab10(np.linspace(0, 1, len(unique_symbols)))
        # colors = [ATOM_COLORS.get(sym, 'gray') for sym in unique_symbols]

        energies_full = np.array(full_energies_ev)
        near_fermi_mask = np.abs(energies_full - fermi_ev) <= energy_window

        atom_contributions = {}
        for atom_symbol in unique_symbols:
            atom_indices = [i for i, sym in enumerate(symbols)
                            if sym == atom_symbol]
            basis_indices = np.\
                concatenate([np.where(atoms == (idx + 1))[0]
                             for idx in atom_indices]
                            )
            pdos_total = np.sum(raw_pdos[basis_indices, :], axis=0)
            pdos_sum = pdos_total[energy_mask]
            atom_contributions[atom_symbol] = pdos_sum

            # fermi_contribution = (np.trapz(pdos_total[near_fermi_mask], x=energies_full[near_fermi_mask])
            #                       if np.sum(near_fermi_mask) >= 2 else np.sum(pdos_total[near_fermi_mask]))
            fermi_contribution = np.trapz(pdos_total[near_fermi_mask],
                                          x=energies_full[near_fermi_mask])
            for idx in atom_indices:
                top_atoms.append((idx + 1, atom_symbol, fermi_contribution))

        # sorted_atoms = sorted(atom_contributions.items(), key=lambda x: np.max(x[1]), reverse=True)
        sorted_atoms = sorted(atom_contributions.items(),
                              key=lambda x: np.max(x[1]))
        sorted_top = sorted(top_atoms, key=lambda x: x[2], reverse=True)
        index = 0
        for atom_symbol, pdos_sum in sorted_atoms:
            color = ATOM_COLORS.get(atom_symbol, 'gray')
            ax.fill_betweenx(energies_ev,
                             bottom,
                             bottom + pdos_sum, color=color,
                             alpha=0.9-index,
                             label=atom_symbol)
            bottom += pdos_sum
            index += 0.1

        total_dos = np.sum(raw_pdos, axis=0)[energy_mask]
        ax.plot(total_dos, energies_ev, color='black', linestyle='--', linewidth=1.5, alpha=0.6, label='Total DOS')
        # ax.fill_betweenx(energies_ev,
        #          0,
        #          total_dos,
        #          color='black',
        #          alpha=0.9,
        #          label='Total DOS')

        fermi_line = 0 if self.shift_to_fermi else fermi_ev
        ax.axhline(fermi_line,
                   linestyle='-',
                   color='black',
                   linewidth=1,
                   label='Fermi'
                   )
        ax.set_xlabel("DOS (eV)", fontsize=16)
        ax.set_ylabel("Energy (eV)", fontsize=16)
        handles, labels = ax.get_legend_handles_labels()

        fermi_items = [(h, l) for h, l in zip(handles, labels) if l.lower() == 'fermi']
        other_items = [(h, l) for h, l in zip(handles, labels) if l.lower() != 'fermi']

        sorted_other = sorted(other_items, key=lambda x: x[1])
        sorted_handles, sorted_labels =\
            zip(*sorted_other) if sorted_other else ([], [])

        if fermi_items:
            sorted_handles += (fermi_items[0][0],)
            sorted_labels += (fermi_items[0][1],)

        ax.legend(sorted_handles,
                  sorted_labels,
                  fontsize=14,
                  loc='upper left',
                  bbox_to_anchor=(1.02, 1),
                  borderaxespad=0)

        # Sort legend alphabetically by symbol
        # handles, labels = ax.get_legend_handles_labels()
        # sorted_pairs = sorted(zip(labels, handles), key=lambda x: x[0])  # sort by symbol
        # sorted_labels, sorted_handles = zip(*sorted_pairs)
        # ax.legend(sorted_handles, sorted_labels, fontsize=14, loc='upper left', bbox_to_anchor=(1.02, 1), borderaxespad=0)

        # ax.legend(fontsize=14)
        # ax.legend(fontsize=14, loc='upper left', bbox_to_anchor=(1.02, 1), borderaxespad=0)
        ax.tick_params(labelsize=14)
        ax.set_xlim(left=0)
        ax.set_ylim(*self.ylim)
        fig.tight_layout()
        plt.subplots_adjust(right=0.75)
        fig.savefig(f'{self.save_path}-by-atoms.png',
                    dpi=400, bbox_inches='tight')
        # plt.show()

        return ax, sorted_top

    def plot_by_orbital(self,
                        energies_ev,
                        raw_pdos,
                        lvals,
                        energy_mask,
                        fermi_ev):
        """
        Plot orbital-wise PDOS contributions grouped by angular momentum.

        Args:
            energies_ev (np.ndarray): Energy values (masked).
            raw_pdos (np.ndarray): Raw PDOS array.
            lvals (np.ndarray): Angular momentum indices.
            energy_mask (np.ndarray): Energy mask.
            fermi_ev (float): Fermi energy in eV.

        Returns:
            matplotlib.axes.Axes: Axes of the plot.
        """
        fig, ax = plt.subplots(figsize=(6, 10))
        bottom = np.zeros_like(energies_ev)

        for orb in self.orbital_labels.values():
            indices =\
                np.where(lvals==list(self.orbital_labels.keys())[list(self.orbital_labels.values()).index(orb)])[0]
            if len(indices) > 0:
                pdos_sum =\
                    np.sum(raw_pdos[indices, :], axis=0)[energy_mask]
                ax.fill_betweenx(energies_ev,
                                 bottom,
                                 bottom + pdos_sum,
                                 color=self.orbital_colors[orb],
                                 alpha=0.9,
                                 label=orb)
                bottom += pdos_sum
        total_dos = np.sum(raw_pdos, axis=0)[energy_mask]
        ax.plot(total_dos, energies_ev, color='black', linewidth=1.5, label='Total DOS')
        fermi_line = 0 if self.shift_to_fermi else fermi_ev
        ax.axhline(fermi_line,
                   linestyle='-',
                   color='black',
                   linewidth=1,
                   label='Fermi')
        ax.set_xlabel("DOS (eV)",
                      fontsize=16)
        ax.set_ylabel("Energy (eV)",
                      fontsize=16)
        ax.legend(fontsize=14,
                  loc='upper left',
                  bbox_to_anchor=(1.02, 1),
                  borderaxespad=0)
        # ax.legend(fontsize=14)
        ax.tick_params(labelsize=14)
        ax.set_xlim(left=0)
        ax.set_ylim(*self.ylim)
        fig.tight_layout()
        plt.subplots_adjust(right=0.75)
        fig.savefig(f'{self.save_path}-by-orbitals.png',
                    dpi=400,
                    bbox_inches='tight'
                    )
        # plt.show()

        return ax

    def plot(self,
             energy_window=0.2,
             plot_atoms=True,
             plot_orbitals=True
             ):
        """
        Main method to generate plots for atom-wise
        and/or orbital-wise PDOS.

        **Parameters:**
            - energy_window (float): Window around
                Fermi level (in eV) for integration.
            - plot_atoms (bool): Whether to generate
                atom-wise PDOS plot.
            - plot_orbitals (bool): Whether to generate
                orbital-wise PDOS plot.
        """
        data_json = {}
        energies_ev, full_energies_ev, raw_pdos, atoms, lvals, symbols, energy_mask, fermi_ev =\
            self.load_data()
        data_json['energies_ev'] = energies_ev.tolist()
        data_json['full_energies_ev'] = full_energies_ev.tolist()
        data_json['raw_pdos'] = raw_pdos
        data_json['atoms'] = atoms
        data_json['lvals'] = lvals
        data_json['symbols'] = symbols
        data_json['energy_mask'] = energy_mask
        data_json['fermi_ev'] = fermi_ev
        filetyper.write_minified_json_gz(data_json, f'{self.save_path}-json.gz')




        if plot_atoms:
            ax, sorted_top = self.plot_by_atom(energies_ev,
                                               full_energies_ev,
                                               raw_pdos,
                                               atoms,
                                               symbols,
                                               energy_mask,
                                               fermi_ev,
                                               energy_window
                                               )
            self._write_atom_contribution_csv(sorted_top)
        if plot_orbitals:
            self.plot_by_orbital(energies_ev,
                                 raw_pdos,
                                 lvals,
                                 energy_mask,
                                 fermi_ev
                                 )


# if __name__ == "__main__":
def main():

    parser = argparse.ArgumentParser(description="Plot PDOS from AMS BAND RKF")
    parser.add_argument("rkf_path",
                        help="Path to the RKF file"
                        )
    parser.add_argument("--save_path",
                        default="PDOS",
                        help="Filename prefix for saved plots"
                        )
    parser.add_argument("--ylim",
                        nargs=2,
                        type=float,
                        default=[-10, 10],
                        help="Y-axis energy limits in eV"
                        )
    parser.add_argument("--shift_to_fermi",
                        action="store_true",
                        help="Shift energies so Fermi level is at 0"
                        )
    parser.add_argument("--window",
                        type=float,
                        default=0.2,
                        help="Energy window around Fermi level (eV)"
                        )
    parser.add_argument("--no_atoms",
                        action="store_true",
                        help="Skip plotting atom-wise PDOS"
                        )
    parser.add_argument("--no_orbitals",
                        action="store_true",
                        help="Skip plotting orbital-wise PDOS"
                        )

    args = parser.parse_args()

    plotter = PDOSPlotter(
        path_to_rkf=args.rkf_path,
        ylim=tuple(args.ylim),
        save_path=args.save_path,
        shift_to_fermi=args.shift_to_fermi
        )

    plotter.plot(energy_window=args.window,
                 plot_atoms=not args.no_atoms,
                 plot_orbitals=not args.no_orbitals
                 )